/* ----------------------------------------------------------------------------------------------- */
/*  Copyright (c) 2008 - 2017 by Mikahil Tsyganov, tsyganov.michail@yandex.ru                                     */
/*                                                                                                 */
/*  Разрешается повторное распространение и использование как в виде исходного кода, так и         */
/*  в двоичной форме, с изменениями или без, при соблюдении следующих условий:                     */
/*                                                                                                 */
/*   1. При повторном распространении исходного кода должно оставаться указанное выше уведомление  */
/*      об авторском праве, этот список условий и последующий отказ от гарантий.                   */
/*   2. При повторном распространении двоичного кода должна сохраняться указанная выше информация  */
/*      об авторском праве, этот список условий и последующий отказ от гарантий в документации     */
/*      и/или в других материалах, поставляемых при распространении.                               */
/*   3. Ни имя владельца авторских прав, ни имена его соратников не могут быть использованы в      */
/*      качестве рекламы или средства продвижения продуктов, основанных на этом ПО без             */
/*      предварительного письменного разрешения.                                                   */
/*                                                                                                 */
/*  ЭТА ПРОГРАММА ПРЕДОСТАВЛЕНА ВЛАДЕЛЬЦАМИ АВТОРСКИХ ПРАВ И/ИЛИ ДРУГИМИ СТОРОНАМИ "КАК ОНА ЕСТЬ"  */
/*  БЕЗ КАКОГО-ЛИБО ВИДА ГАРАНТИЙ, ВЫРАЖЕННЫХ ЯВНО ИЛИ ПОДРАЗУМЕВАЕМЫХ, ВКЛЮЧАЯ, НО НЕ             */
/*  ОГРАНИЧИВАЯСЬ ИМИ, ПОДРАЗУМЕВАЕМЫЕ ГАРАНТИИ КОММЕРЧЕСКОЙ ЦЕННОСТИ И ПРИГОДНОСТИ ДЛЯ КОНКРЕТНОЙ */
/*  ЦЕЛИ. НИ В КОЕМ СЛУЧАЕ НИ ОДИН ВЛАДЕЛЕЦ АВТОРСКИХ ПРАВ И НИ ОДНО ДРУГОЕ ЛИЦО, КОТОРОЕ МОЖЕТ    */
/*  ИЗМЕНЯТЬ И/ИЛИ ПОВТОРНО РАСПРОСТРАНЯТЬ ПРОГРАММУ, КАК БЫЛО СКАЗАНО ВЫШЕ, НЕ НЕСЁТ              */
/*  ОТВЕТСТВЕННОСТИ, ВКЛЮЧАЯ ЛЮБЫЕ ОБЩИЕ, СЛУЧАЙНЫЕ, СПЕЦИАЛЬНЫЕ ИЛИ ПОСЛЕДОВАВШИЕ УБЫТКИ,         */
/*  ВСЛЕДСТВИЕ ИСПОЛЬЗОВАНИЯ ИЛИ НЕВОЗМОЖНОСТИ ИСПОЛЬЗОВАНИЯ ПРОГРАММЫ (ВКЛЮЧАЯ, НО НЕ             */
/*  ОГРАНИЧИВАЯСЬ ПОТЕРЕЙ ДАННЫХ, ИЛИ ДАННЫМИ, СТАВШИМИ НЕПРАВИЛЬНЫМИ, ИЛИ ПОТЕРЯМИ ПРИНЕСЕННЫМИ   */
/*  ИЗ-ЗА ВАС ИЛИ ТРЕТЬИХ ЛИЦ, ИЛИ ОТКАЗОМ ПРОГРАММЫ РАБОТАТЬ СОВМЕСТНО С ДРУГИМИ ПРОГРАММАМИ),    */
/*  ДАЖЕ ЕСЛИ ТАКОЙ ВЛАДЕЛЕЦ ИЛИ ДРУГОЕ ЛИЦО БЫЛИ ИЗВЕЩЕНЫ О ВОЗМОЖНОСТИ ТАКИХ УБЫТКОВ.            */
/*                                                                                                 */
/*   ak_rc6.c                                                                                    */
/* ----------------------------------------------------------------------------------------------- */

#include <stdint.h>
#include <stdlib.h>

#include <ak_skey.h>

/* ----------------------------------------------------------------------------------------------- */

#define RC6_ROUNDS  20              // Количество раундов
#define KEY_LENGTH  256             // Длина ключа в битах
#define W           32              // Длина машинного слова в битах
#define P32         0xB7E15163      // "Магическая" константа на основе экспоненты
#define Q32         0x9E3779B9      // "Магическая" константа на основе золотого сечения
#define LG_W        5               // Значение двоичного логарифма от W (log2(32))

/* ----------------------------------------------------------------------------------------------- */

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Функция создает контекст ключа блочного алгоритма шифрования RC6

   После выполнения данной функции создается указатель на контекст ключа и устанавливаются
   обработчики (функции класса). Однако само значение ключу не присваивается -
   поле bkey->key остается равным NULL.

   \b Внимание. Данная функция предназначена для использования другими функциями и не должна
   вызываться напрямую.

   @return Функция возвращает указатель на созданный контекст. В случае возникновения ошибки,
   возвращается NULL, код ошибки может быть получен с помощью вызова функции ak_error_get_value()  */
/* ----------------------------------------------------------------------------------------------- */
ak_bckey ak_bckey_rc6_new(void)
{
    ak_bckey bkey = NULL;

    /* Cоздаем ключ алгоритма шифрования и определяем его методы */
    if(( bkey = ak_bckey_new( 32, 16 )) == NULL ) {
        ak_error_message( ak_error_null_pointer, __func__ , "incorrect memory allocation" );
        return NULL;
    }

    /* Устанавливаем OID алгоритма шифрования */
    if(( bkey->key.oid = ak_oids_find_by_name( "rc6" )) == NULL ) {
        int error = ak_error_get_value();
        ak_error_message( error, __func__, "wrong search of predefined rc6 block cipher OID" );
        return ( bkey = ak_bckey_delete( bkey ));
    }

    /* Устанавливаем данные ключа */
    bkey->key.data =        NULL;
    bkey->key.set_mask =    ak_skey_set_mask_additive;
    bkey->key.remask =      ak_skey_remask_additive;
    bkey->key.set_icode =   ak_skey_set_icode_additive;
    bkey->key.check_icode = ak_skey_check_icode_additive;

    /* Устанавливаем методы */
    bkey->shedule_keys =    ak_rc6_key_schedule;
    bkey->delete_keys =     ak_rc6_key_delete;
    bkey->encrypt =         ak_rc6_encrypt;
    bkey->decrypt =         ak_rc6_decrypt;

    return bkey;
}

/* ----------------------------------------------------------------------------------------------- */

/*! Контекст RC6 */
typedef struct
{
    uint8_t r;      // Число раундов, по умолчанию 20
    uint32_t *S;    // 32-битные раундовые ключи
} rc6_ctx_t;

rc6_ctx_t* ak_rc6_ctx_create_new()
{
    rc6_ctx_t *new_ctx = malloc(sizeof(rc6_ctx_t));
    new_ctx->S = (uint32_t*) calloc(2*ROUNDS+4, sizeof(uint32_t));
    new_ctx->r = ROUNDS;
    return new_ctx;
}

void ak_rc6_ctx_free(rc6_ctx_t *ctx)
{
    free(ctx->S);
    free(ctx);
}

/*! \brief Функция выполняет циклический сдвиг 32-битного числа влево. */
uint32_t rol32(uint32_t a, uint8_t n)
{
    return (a << n) | (a >> (32 - n));
}

/*! \brief Функция выполняет циклический сдвиг 32-битного числа вправо. */
uint32_t ror32(uint32_t a, uint8_t n)
{
    return (a >> n) | (a << (32 - n));
}

/*! \brief Функция выполняет развертку ключа. */
void ak_rc6_key_schedule(rc6_ctx_t *ctx, void *key)
{
    ctx->S[0] = P32;
    uint8_t i = 0, j = 0;
    for(i = 1; i <= 2*ctx->r+3; ++i)
        ctx->S[i] = ctx->S[i-1] + Q32;

    i = 0;
    uint32_t a = 0, b = 0;
    for(uint8_t k=1; k<=3*(2*ctx->r+4); ++k)
    {
        a = ctx->S[i] = rol32((ctx->S[i] + a + b), 3);
        b = ((uint32_t*)key)[j] = rol32(((uint32_t*)key)[j] + a + b, a + b);
        i = (i+1) % (2*ctx->r+4);
        j = (j+1) % (KEY_LENGTH/W);
    }
}

/*! \brief Функция выполняет удаление текущих раундовых ключей. */
void ak_rc6_key_delete(rc6_ctx_t *ctx)
{
    free(ctx->S);
}

/*! \brief Функция выполняет зашифрование одного блока информации алгоритмом RC6. */
void ak_rc6_encrypt(rc6_ctx_t *ctx, void* block)
{
    register uint32_t A = ((uint32_t *)block)[0];
    register uint32_t B = ((uint32_t *)block)[1];
    register uint32_t C = ((uint32_t *)block)[2];
    register uint32_t D = ((uint32_t *)block)[3];

    B += ctx->S[0];
    D += ctx->S[1];
    uint32_t t=0, u=0, temp_reg;
    for(uint8_t i = 1; i <= ctx->r; ++i)
    {
        t = rol32((B * (2 * B + 1)), LG_W);
        u = rol32((D * (2 * D + 1)), LG_W);
        A = rol32(A ^ t, u) + ctx->S[2*i];
        C = rol32(C ^ u, t) + ctx->S[2*i+1];
        temp_reg = A;
        A = B;
        B = C;
        C = D;
        D = temp_reg;
    }
    A += ctx->S[2*ctx->r + 2];
    C += ctx->S[2*ctx->r + 3];
    ((uint32_t *)block)[0]=A;
    ((uint32_t *)block)[1]=B;
    ((uint32_t *)block)[2]=C;
    ((uint32_t *)block)[3]=D;
}

/*! \brief Функция выполняет расшифрование одного блока информации алгоритмом RC6. */
void ak_rc6_decrypt(rc6_ctx_t *ctx, void *block)
{
    register uint32_t A = ((uint32_t *)block)[0];
    register uint32_t B = ((uint32_t *)block)[1];
    register uint32_t C = ((uint32_t *)block)[2];
    register uint32_t D = ((uint32_t *)block)[3];
    C = C - ctx->S[2*ctx->r + 3];
    A = A - ctx->S[2*ctx->r + 2];
    uint32_t t=0, u=0, temp_reg;
    for(uint8_t i = ctx->r; i > 0; --i)
    {
        temp_reg = D;
        D = C;
        C = B;
        B = A;
        A = temp_reg;
        t = rol32((B*(2*B+1)), LG_W);
        u = rol32((D*(2*D+1)), LG_W);
        C = ror32((C-ctx->S[2*i+1]), t) ^ u;
        A = ror32((A-ctx->S[2*i]), u) ^ t;
    }
    D = D - ctx->S[1];
    B = B - ctx->S[0];
    ((uint32_t *)block)[0]=A;
    ((uint32_t *)block)[1]=B;
    ((uint32_t *)block)[2]=C;
    ((uint32_t *)block)[3]=D;
}

/* ----------------------------------------------------------------------------------------------- */
/*                                                                                       ak_rc6.c  */
/* ----------------------------------------------------------------------------------------------- */
